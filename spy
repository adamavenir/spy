#!/usr/bin/env bash
set -euo pipefail

CLAUDE_PROJECTS="$HOME/.claude/projects"
CODEX_SESSIONS="$HOME/.codex/sessions"
ACTIVE_WINDOW_SECONDS=60

# --- Session discovery ---

get_claude_project_path() {
    local cwd="${1:-$(pwd)}"
    echo "$cwd" | sed 's|^/||; s|/|-|g; s|^|-|'
}

find_claude_sessions() {
    local cwd="${1:-$(pwd)}"
    local project_path
    project_path=$(get_claude_project_path "$cwd")
    local project_dir="$CLAUDE_PROJECTS/$project_path"

    [[ ! -d "$project_dir" ]] && return

    local now
    now=$(date +%s)

    while IFS= read -r file; do
        [[ -z "$file" || ! -f "$file" ]] && continue
        local size
        size=$(stat -f %z "$file" 2>/dev/null || stat -c %s "$file" 2>/dev/null)
        [[ "$size" -eq 0 ]] && continue
        local mtime
        mtime=$(stat -f %m "$file" 2>/dev/null || stat -c %Y "$file" 2>/dev/null)
        local age=$((now - mtime))
        echo "claude|$file|$age|$mtime"
    done < <(ls -t "$project_dir"/*.jsonl 2>/dev/null | head -50)
}

find_codex_sessions() {
    local cwd="${1:-$(pwd)}"
    local now
    now=$(date +%s)

    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        local session_cwd
        session_cwd=$(head -1 "$file" 2>/dev/null | jq -r '.payload.cwd // empty' 2>/dev/null)
        [[ -z "$session_cwd" || "$session_cwd" != "$cwd" ]] && continue
        local mtime
        mtime=$(stat -f %m "$file" 2>/dev/null || stat -c %Y "$file" 2>/dev/null)
        local age=$((now - mtime))
        echo "codex|$file|$age|$mtime"
    done < <(find "$CODEX_SESSIONS" -name "*.jsonl" -type f 2>/dev/null)
}

get_all_sessions() {
    local cwd="${1:-$(pwd)}"
    {
        find_claude_sessions "$cwd"
        find_codex_sessions "$cwd"
    } | sort -t'|' -k4 -rn
}

# Get session by index (1-based, sorted by recency)
get_session_by_index() {
    local n="$1"
    local sessions="$2"
    echo "$sessions" | sed -n "${n}p"
}

count_active_sessions() {
    local sessions="$1"
    local count=0
    while IFS='|' read -r type file age mtime; do
        [[ -z "$type" ]] && continue
        [[ $age -le $ACTIVE_WINDOW_SECONDS ]] && ((count++))
    done <<< "$sessions"
    echo "$count"
}

# --- Text extraction ---

# Extract all parsed text lines from a Claude session
extract_claude_text() {
    local file="$1"
    jq -r '
        select((.type == "user" or .type == "assistant") and .message != null) |
        .message |
        (if .content == null then empty
         elif (.content | type) == "string" then .content
         elif (.content | type) == "array" then
           (.content[] | select(.type == "text") | .text) // empty
         else empty end) //
        empty
    ' "$file" 2>/dev/null
}

# Extract all parsed text lines from a Codex session
extract_codex_text() {
    local file="$1"
    jq -r '
        select(.type == "response_item" and .payload.role != null) |
        select(.payload.role == "user" or .payload.role == "assistant") |
        .payload.content[0].text // empty |
        select(test("^# AGENTS|^<INSTRUCTIONS|^<environment_context|^<permissions|^<turn_aborted") | not) |
        select(length > 0)
    ' "$file" 2>/dev/null
}

extract_text() {
    local type="$1"
    local file="$2"
    if [[ "$type" == "claude" ]]; then
        extract_claude_text "$file"
    else
        extract_codex_text "$file"
    fi
}

# --- Formatting ---

format_time_ago() {
    local seconds="$1"
    if [[ $seconds -lt 60 ]]; then
        echo "${seconds}s ago"
    elif [[ $seconds -lt 3600 ]]; then
        echo "$((seconds / 60))m ago"
    elif [[ $seconds -lt 86400 ]]; then
        echo "$((seconds / 3600))h ago"
    else
        echo "$((seconds / 86400))d ago"
    fi
}

truncate_line() {
    local text="$1"
    local max="${2:-80}"
    if [[ ${#text} -gt $max ]]; then
        echo "${text:0:$max}..."
    else
        echo "$text"
    fi
}

# --- Views ---

# Accordion: first 3 lines + "..." + last 10 lines
show_accordion() {
    local type="$1"
    local file="$2"
    local age="$3"

    local text
    text=$(extract_text "$type" "$file")

    if [[ -z "$text" ]]; then
        echo "(empty session)"
        return
    fi

    local total_lines
    total_lines=$(echo "$text" | wc -l | tr -d ' ')

    local time_str
    time_str=$(format_time_ago "$age")

    if [[ $total_lines -le 13 ]]; then
        echo "$text"
    else
        echo "$text" | head -3
        echo "..."
        echo "$text" | tail -10
    fi
    echo ""
    echo "  $time_str [$type] ($total_lines lines)"
}

# List view: compact summary per session
show_list_item() {
    local num="$1"
    local type="$2"
    local file="$3"
    local age="$4"

    local first_line last_line
    first_line=$(extract_text "$type" "$file" | head -1)
    last_line=$(tail -200 "$file" 2>/dev/null | if [[ "$type" == "claude" ]]; then
        jq -r 'select((.type == "user" or .type == "assistant") and .message != null) | .message | (if (.content | type) == "string" then .content elif (.content | type) == "array" then (.content[] | select(.type == "text") | .text) // empty else empty end) // empty' 2>/dev/null | tail -1
    else
        jq -r 'select(.type == "response_item" and (.payload.role == "user" or .payload.role == "assistant")) | .payload.content[0].text // empty | select(length > 0)' 2>/dev/null | tail -1
    fi)

    first_line=$(echo "$first_line" | tr '\n' ' ' | sed 's/  */ /g')
    last_line=$(echo "$last_line" | tr '\n' ' ' | sed 's/  */ /g')

    local time_str
    time_str=$(format_time_ago "$age")

    echo "[$num] \"$(truncate_line "$first_line" 60)\""
    echo "... \"$(truncate_line "$last_line" 60)\""
    echo "    $time_str [$type]"
    echo ""
}

# Watch mode: follow a session live
watch_session() {
    local type="$1"
    local file="$2"

    echo "Watching $type session (Ctrl-C to stop)"
    echo "---"

    if [[ "$type" == "claude" ]]; then
        tail -f "$file" 2>/dev/null | jq --unbuffered -r '
            select((.type == "user" or .type == "assistant") and .message != null) |
            "\n[\(.type)]",
            (.message |
                if (.content | type) == "string" then .content
                elif (.content | type) == "array" then
                    (.content[] | select(.type == "text") | .text) // empty
                else empty end) //
            empty
        ' 2>/dev/null
    else
        tail -f "$file" 2>/dev/null | jq --unbuffered -r '
            select(.type == "response_item" and (.payload.role == "user" or .payload.role == "assistant")) |
            "\n[\(.payload.role)]",
            (.payload.content[0].text // empty) |
            select(length > 0)
        ' 2>/dev/null
    fi
}

# --- Argument parsing ---

main() {
    local cwd
    cwd=$(pwd)
    local session_num=""
    local command=""
    local count=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            ls)
                command="ls"
                shift
                ;;
            watch)
                command="watch"
                shift
                ;;
            tail)
                command="tail"
                shift
                if [[ $# -gt 0 && "$1" =~ ^-?[0-9]+$ ]]; then
                    count="${1#-}"
                    shift
                fi
                ;;
            head)
                command="head"
                shift
                if [[ $# -gt 0 && "$1" =~ ^-?[0-9]+$ ]]; then
                    count="${1#-}"
                    shift
                fi
                ;;
            -h|--help)
                command="help"
                shift
                ;;
            [0-9]*)
                session_num="$1"
                shift
                ;;
            *)
                echo "Unknown argument: $1"
                echo "Run 'spy --help' for usage."
                exit 1
                ;;
        esac
    done

    # Resolve sessions
    local sessions
    sessions=$(get_all_sessions "$cwd")

    if [[ -z "$sessions" ]]; then
        echo "No sessions found for $cwd"
        exit 0
    fi

    # Execute command
    case "${command:-default}" in
        help)
            show_help
            ;;
        ls)
            cmd_ls "$sessions"
            ;;
        watch)
            cmd_watch "$sessions" "$session_num"
            ;;
        tail)
            cmd_tail "$sessions" "$session_num" "${count:-30}"
            ;;
        head)
            cmd_head "$sessions" "$session_num" "${count:-5}"
            ;;
        default)
            cmd_default "$sessions" "$session_num"
            ;;
    esac
}

show_help() {
    cat <<'EOF'
spy - Monitor active Claude Code and Codex conversations

Usage:
  spy              Show accordion of most recent session, or list if multiple active
  spy <n>          Show accordion of session #n
  spy watch        Follow the most recent session live
  spy <n> watch    Follow session #n live
  spy tail -30     Last 30 lines of parsed text from most recent session
  spy head -5      First 5 lines of parsed text from most recent session
  spy <n> tail -N  Last N lines from session #n
  spy <n> head -N  First N lines from session #n
  spy ls           List active sessions + 5 most recent

Sessions are numbered by recency (1 = most recent).
Active = updated within last 60s.
EOF
}

resolve_session() {
    local sessions="$1"
    local session_num="$2"
    local n="${session_num:-1}"
    local entry
    entry=$(get_session_by_index "$n" "$sessions")
    if [[ -z "$entry" ]]; then
        echo "No session #$n found" >&2
        exit 1
    fi
    echo "$entry"
}

cmd_default() {
    local sessions="$1"
    local session_num="$2"

    if [[ -n "$session_num" ]]; then
        # Specific session: show accordion
        local entry
        entry=$(resolve_session "$sessions" "$session_num")
        IFS='|' read -r type file age mtime <<< "$entry"
        show_accordion "$type" "$file" "$age"
        return
    fi

    # Check how many active sessions
    local active_count
    active_count=$(count_active_sessions "$sessions")

    if [[ $active_count -gt 1 ]]; then
        cmd_ls "$sessions"
    else
        # Show accordion of most recent session
        local entry
        entry=$(get_session_by_index 1 "$sessions")
        IFS='|' read -r type file age mtime <<< "$entry"
        show_accordion "$type" "$file" "$age"
    fi
}

cmd_ls() {
    local sessions="$1"
    local active_count=0
    local done_count=0
    local num=1
    local done_num=1

    echo "=== Active ==="
    echo ""
    while IFS='|' read -r type file age mtime; do
        [[ -z "$type" ]] && continue
        if [[ $age -le $ACTIVE_WINDOW_SECONDS ]]; then
            show_list_item "$num" "$type" "$file" "$age"
            ((num++))
            ((active_count++))
        fi
    done <<< "$sessions"

    if [[ $active_count -eq 0 ]]; then
        echo "(none)"
        echo ""
    fi

    echo "=== Recent ==="
    echo ""
    while IFS='|' read -r type file age mtime; do
        [[ -z "$type" ]] && continue
        if [[ $age -gt $ACTIVE_WINDOW_SECONDS && $done_count -lt 5 ]]; then
            show_list_item "$done_num" "$type" "$file" "$age"
            ((done_num++))
            ((done_count++))
        fi
    done <<< "$sessions"

    if [[ $done_count -eq 0 ]]; then
        echo "(none)"
        echo ""
    fi
}

cmd_watch() {
    local sessions="$1"
    local session_num="$2"
    local entry
    entry=$(resolve_session "$sessions" "$session_num")
    IFS='|' read -r type file age mtime <<< "$entry"
    watch_session "$type" "$file"
}

cmd_tail() {
    local sessions="$1"
    local session_num="$2"
    local n="$3"
    local entry
    entry=$(resolve_session "$sessions" "$session_num")
    IFS='|' read -r type file age mtime <<< "$entry"
    extract_text "$type" "$file" | tail -"$n"
}

cmd_head() {
    local sessions="$1"
    local session_num="$2"
    local n="$3"
    local entry
    entry=$(resolve_session "$sessions" "$session_num")
    IFS='|' read -r type file age mtime <<< "$entry"
    extract_text "$type" "$file" | head -"$n"
}

main "$@"
